# Basic_closure
A Simple Implementation of Closure in C++

## Problems
Think about how bind and function are implemented?

Back to the definition of closure, in fact, as long as the function pointer, function parameters and object pointer are encapsulated into a structure. 
There are two main problems here:
1. different parameter types
2. The number of parameters is different

## Solution
Use templates
To define a closure struct for the possible number of arguments.
Which means, as many parameters, we define as many corresponding closure structures.

### Define a base class closure
```c++
class Closure {
public:
    Closure() {}
    ~Closure() {}

    virtual void Run() = 0;
};//Closure
```
### Closures corresponding to ordinary functions without parameters:
```c++
class FunctionClosure0 : public Closure {
public:
    typedef void (*FunctionType)();

    FunctionClosure0(FunctionType f) :
        _f(f) {
        }
    ~FunctionClosure0() {
    }

    virtual void Run() {
        _f();
        delete this;
    }
private:
    FunctionType _f;
};//FunctionClosure0
```

FunctionType is used to store function pointers. Note that the object itself comes from the NewCallback function, so call delete this in the Run method to clean up itself to prevent memory leaks caused by forgetting to delete.

NewPermanentCallback is also provided in protobuf. When the Closure object generated by this method calls the Run method, it will not call delete this. The implementation is to add a bool to the Closure class to record whether the delete method needs to be called.

The NewCallback corresponding to the Closure is:
```c++
Closure* NewCallback(void (*function)()) {
    return new FunctionClosure0(function);
}
```

All NewCallbacks return a pointer to a Closure object, so the incoming function pointer type is different, but the return type is the same.

### Closures for parameterless member functions
```c++
template <typename Class>
class MethodClosure0 : public Closure {
public:
    typedef void (Class::*MethodType)();

    MethodClosure0(Class* object, MethodType m) :
        _object(object),
        _m(m) {
        }
    ~MethodClosure0() {
    }

    virtual void Run() {
        std::cout << "address of object in Run : " << _object << std::endl;
        (_object->*_m)();
        delete this;
    }
private:
    Class* _object;
    MethodType _m;
};//MethodClosure0
```
The closure class corresponding to ordinary functions is not much different, mainly including:

1. Need to pass in the class template
2. The function definitions are different, the ordinary function pointer is typedef void (\*FunctionType)(), and the member function is typedef void (Class::\*MethodType)()
3. The constructor needs to pass in the object pointer corresponding to the class and save it as a member variable
4. The way to use (\_object->\*\_m)() when calling
Corresponding NewCallback:
```c++
template <typename Class>
Closure* NewCallback(Class* object, void (Class::*method)()) {
    return new MethodClosure0<Class>(object, method);
}
```
Similarly, closure objects with different numbers of parameters can be implemented through templates. 
In each case, two closure objects and two NewCallback functions need to be implemented.

### For example, for single parameter
```c++
template <typename Arg1>
class FunctionClosure1 : public Closure {
public:
    typedef void (*FunctionType)(Arg1);

    FunctionClosure1(FunctionType f, Arg1 arg1) :
        _f(f),
        _arg1(arg1) {
        }
    ~FunctionClosure1() {
    }

    virtual void Run() {
        _f(_arg1);
        delete this;
    }
private:
    FunctionType _f;
    Arg1 _arg1;
};//FunctionClosure1

template <typename Class, typename Arg1>
class MethodClosure1 : public Closure {
public:
    typedef void (Class::*MethodType)(Arg1);

    MethodClosure1(Class* object, MethodType m, Arg1 arg1) :
        _object(object),
        _m(m),
        _arg1(arg1) {
        }
    ~MethodClosure1() {
    }

    virtual void Run() {
        std::cout << "address of object in Run : " << _object << std::endl;
        (_object->*_m)(_arg1);
        delete this;
    }
private:
    Class* _object;
    MethodType _m;
    Arg1 _arg1;
};//MethodClosure1

template <typename Arg1>
Closure* NewCallback(void(*function)(Arg1), Arg1 arg1) {
    return new FunctionClosure1<Arg1>(function, arg1);
}

template <typename Class, typename Arg1>
Closure* NewCallback(Class* object, void (Class::*method)(Arg1), Arg1 arg1) {
    return new MethodClosure1<Class, Arg1>(object, method, arg1);
}
```

The difference is that parameter templates are added and parameters are saved in the Closure subclass.
In actual use, users can choose how many classes and NewCallback corresponding to the parameters are generated. The code generation is regular, and interested friends can write a script to implement it.

## More improvements

More issues should be considered in actual use.

Such as how can the incoming object pointer be guaranteed not to be destructed during the asynchronous callback, and if it has been destructed, how to ensure that there is no problem, These require shared_ptr/weak_ptr to appear.

In the chrome source code bind.h, an additional parameter will be passed in the bind parameter, the value is: base::Unretained (closure does not own ownership, used for the AddRef interface), base::Owned (closure has ownership). In addition, by making Foo inherit from RefCountedThreadSafe<Foo> or internally maintain a WeakPtrFactory<Foo> object, etc., a function similar to weak callback is achieved. At the same time, the default bind parameter of chrome is in the form of const T&, which prevents the copying of parameters.
  
## Reference
[protobuf](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/stubs/callback.h)
